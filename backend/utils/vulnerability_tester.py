"""Automated Vulnerability Testing and PoC Execution System"""

import asyncio
import json
import re
import subprocess
import tempfile
import time
from typing import Dict, List, Optional, Any
from urllib.parse import urlparse, urlencode
import httpx
import os


class VulnerabilityTester:
    """Automated vulnerability testing with PoC execution"""
    
    def __init__(self, ollama_host: str = "localhost", ollama_port: int = 11434):
        self.ollama_url = f"http://{ollama_host}:{ollama_port}/api/generate"
        self.test_results = {}
        self.poc_cache = {}
        
    async def test_vulnerability(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Automatically test a detected vulnerability with PoC execution.
        Returns test results with verification status.
        """
        
        vuln_id = vulnerability.get("id", "unknown")
        vuln_type = vulnerability.get("title", "Unknown").lower()
        url = vulnerability.get("affected_url", "")
        method = vulnerability.get("request_method", "GET")
        headers = vulnerability.get("request_headers", {})
        body = vulnerability.get("request_body", "")
        
        print(f"[AUTO-TEST] Testing vulnerability: {vuln_type} at {url}")
        
        test_result = {
            "vulnerability_id": vuln_id,
            "vulnerability_type": vuln_type,
            "target_url": url,
            "test_timestamp": time.time(),
            "test_status": "unknown",
            "verified": False,
            "confidence": 0.0,
            "evidence": [],
            "poc_code": "",
            "execution_output": "",
            "recommendations": []
        }
        
        try:
            # Generate PoC based on vulnerability type
            poc_result = await self._generate_poc(vulnerability)
            test_result["poc_code"] = poc_result.get("code", "")
            test_result["test_method"] = poc_result.get("method", "manual")
            
            # Execute PoC if possible
            if poc_result.get("executable", False):
                execution_result = await self._execute_poc(poc_result, vulnerability)
                test_result.update(execution_result)
            else:
                test_result["test_status"] = "manual_verification_required"
                test_result["recommendations"].append("Manual testing required - automated PoC not possible")
            
        except Exception as e:
            test_result["test_status"] = "error"
            test_result["error"] = str(e)
            print(f"[AUTO-TEST ERROR] {e}")
        
        # Store result
        self.test_results[vuln_id] = test_result
        return test_result
    
    async def _generate_poc(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Generate PoC code using AI"""
        
        vuln_type = vulnerability.get("title", "").lower()
        url = vulnerability.get("affected_url", "")
        method = vulnerability.get("request_method", "GET")
        headers = vulnerability.get("request_headers", {})
        body = vulnerability.get("request_body", "")
        description = vulnerability.get("description", "")
        
        poc_prompt = f"""
Du bist ein Cybersecurity-Experte. Erstelle einen automatisierten Proof-of-Concept Test für diese Vulnerability.

VULNERABILITY DETAILS:
Type: {vuln_type}
URL: {url}
Method: {method}
Headers: {json.dumps(headers, indent=2)}
Body: {body}
Description: {description}

AUFGABE:
Erstelle einen automatisierten Test der verifiziert ob die Vulnerability wirklich existiert.

ANFORDERUNGEN:
1. Verwende Python mit httpx für HTTP Requests
2. Der Code soll executable sein und klare Ergebnisse liefern
3. Teste mit harmlosen Payloads (keine destructive Tests!)
4. Gib klare Success/Failure Indicators zurück
5. Erstelle sichere, ethische Test-Payloads

VULNERABILITY-SPEZIFISCHE TESTS:
- SQL Injection: Teste mit Zeit-basierten oder Error-basierten Payloads
- XSS: Teste mit harmlosen Alert-Payloads oder Reflection-Tests
- IDOR: Teste Parameter-Manipulation mit verschiedenen IDs
- Open Redirect: Teste mit harmlosen Redirect-URLs
- File Upload: Teste erlaubte File-Types und Validierung

Antworte in JSON Format:
{{
    "executable": true/false,
    "method": "automated|semi-automated|manual",
    "code": "Python Code für den automatisierten Test",
    "test_description": "Was der Test macht",
    "expected_indicators": ["Liste von Success-Indikatoren"],
    "safety_notes": ["Sicherheitshinweise für den Test"],
    "payload_type": "harmless|time-based|error-based|reflection"
}}
"""
        
        try:
            async with httpx.AsyncClient(timeout=15.0) as client:
                response = await client.post(self.ollama_url, json={
                    "model": "qwen2.5-coder:latest",
                    "prompt": poc_prompt,
                    "stream": False,
                    "format": "json",
                    "options": {
                        "temperature": 0.3,
                        "max_tokens": 1500
                    }
                })
                
                if response.status_code == 200:
                    ai_response = response.json()
                    return json.loads(ai_response.get("response", "{}"))
                    
        except Exception as e:
            print(f"PoC generation failed: {e}")
        
        # Fallback PoC templates
        return self._get_fallback_poc(vuln_type, url, method)
    
    def _get_fallback_poc(self, vuln_type: str, url: str, method: str) -> Dict[str, Any]:
        """Fallback PoC templates for common vulnerabilities"""
        
        if "sql" in vuln_type.lower():
            return {
                "executable": True,
                "method": "automated",
                "code": f"""
import httpx
import time

async def test_sql_injection():
    # Time-based SQL injection test
    payloads = ["' AND SLEEP(3)--", "'; WAITFOR DELAY '00:00:03'--"]
    
    for payload in payloads:
        start_time = time.time()
        async with httpx.AsyncClient() as client:
            response = await client.{method.lower()}("{url}", params={{"id": payload}})
        end_time = time.time()
        
        if end_time - start_time > 2.5:
            return {{"verified": True, "evidence": f"Time delay: {{end_time - start_time:.2f}}s"}}
    
    return {{"verified": False, "evidence": "No time delays detected"}}
""",
                "test_description": "Time-based SQL injection test",
                "expected_indicators": ["Response time > 2.5 seconds"],
                "payload_type": "time-based"
            }
        
        elif "xss" in vuln_type.lower():
            return {
                "executable": True,
                "method": "automated", 
                "code": f"""
import httpx

async def test_xss():
    # XSS reflection test
    payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>"]
    
    for payload in payloads:
        async with httpx.AsyncClient() as client:
            response = await client.{method.lower()}("{url}", params={{"q": payload}})
        
        if payload in response.text:
            return {{"verified": True, "evidence": f"Payload reflected: {{payload}}"}}
    
    return {{"verified": False, "evidence": "No payload reflection detected"}}
""",
                "test_description": "XSS reflection test",
                "expected_indicators": ["Payload reflected in response"],
                "payload_type": "reflection"
            }
        
        else:
            return {
                "executable": False,
                "method": "manual",
                "code": "# Manual verification required",
                "test_description": "Manual testing recommended",
                "expected_indicators": ["Manual analysis needed"],
                "payload_type": "manual"
            }
    
    async def _execute_poc(self, poc_result: Dict[str, Any], vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the generated PoC code safely"""
        
        execution_result = {
            "test_status": "executed",
            "verified": False,
            "confidence": 0.0,
            "execution_output": "",
            "execution_time": 0.0,
            "evidence": []
        }
        
        try:
            poc_code = poc_result.get("code", "")
            if not poc_code or "# Manual verification required" in poc_code:
                execution_result["test_status"] = "manual_required"
                return execution_result
            
            # Create temporary Python file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
                # Add safety imports and wrapper
                safe_code = f"""
import asyncio
import httpx
import time
import json

{poc_code}

async def main():
    try:
        # Execute the test function
        if 'test_sql_injection' in globals():
            result = await test_sql_injection()
        elif 'test_xss' in globals():
            result = await test_xss()
        else:
            result = {{"verified": False, "evidence": "No test function found"}}
        
        print(json.dumps(result))
    except Exception as e:
        print(json.dumps({{"verified": False, "error": str(e)}}))

if __name__ == "__main__":
    asyncio.run(main())
"""
                f.write(safe_code)
                temp_file = f.name
            
            # Execute with timeout
            start_time = time.time()
            process = subprocess.run(
                ["python", temp_file],
                capture_output=True,
                text=True,
                timeout=10  # 10 second timeout
            )
            execution_time = time.time() - start_time
            
            # Parse results
            if process.returncode == 0:
                try:
                    test_output = json.loads(process.stdout.strip())
                    execution_result.update({
                        "verified": test_output.get("verified", False),
                        "confidence": 0.8 if test_output.get("verified") else 0.2,
                        "execution_output": process.stdout,
                        "execution_time": execution_time,
                        "evidence": [test_output.get("evidence", "")]
                    })
                except json.JSONDecodeError:
                    execution_result["execution_output"] = process.stdout
            else:
                execution_result["test_status"] = "execution_failed"
                execution_result["execution_output"] = process.stderr
            
            # Cleanup
            os.unlink(temp_file)
            
        except subprocess.TimeoutExpired:
            execution_result["test_status"] = "timeout"
            execution_result["execution_output"] = "Test execution timed out"
        except Exception as e:
            execution_result["test_status"] = "error"
            execution_result["execution_output"] = str(e)
        
        return execution_result
    
    def get_test_results(self) -> Dict[str, Any]:
        """Get all test results and statistics"""
        
        total_tests = len(self.test_results)
        verified_vulns = sum(1 for result in self.test_results.values() if result.get("verified", False))
        false_positives = total_tests - verified_vulns
        
        return {
            "total_tests": total_tests,
            "verified_vulnerabilities": verified_vulns,
            "false_positives": false_positives,
            "verification_rate": verified_vulns / total_tests if total_tests > 0 else 0.0,
            "test_results": self.test_results
        }
